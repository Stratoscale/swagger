// Code generated by go-swagger; DO NOT EDIT.

package restapi

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/Stratoscale/swagger/query"
	"github.com/go-openapi/errors"
	"github.com/go-openapi/loads"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"

	"github.com/Stratoscale/swagger/example/models"
	"github.com/Stratoscale/swagger/example/restapi/operations"
	"github.com/Stratoscale/swagger/example/restapi/operations/pet"
	"github.com/Stratoscale/swagger/example/restapi/operations/store"
)

//go:generate mockery -name PetAPI -inpkg

// PetAPI
type PetAPI interface {
	PetCreate(ctx context.Context, params pet.PetCreateParams) middleware.Responder
	PetDelete(ctx context.Context, params pet.PetDeleteParams) middleware.Responder
	PetGet(ctx context.Context, params pet.PetGetParams) middleware.Responder
	PetList(ctx context.Context, params pet.PetListParams) middleware.Responder
	PetUpdate(ctx context.Context, params pet.PetUpdateParams) middleware.Responder
}

//go:generate mockery -name StoreAPI -inpkg

// StoreAPI
type StoreAPI interface {
	InventoryGet(ctx context.Context, params store.InventoryGetParams) middleware.Responder
	OrderCreate(ctx context.Context, params store.OrderCreateParams) middleware.Responder
	// OrderDelete is For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors
	OrderDelete(ctx context.Context, params store.OrderDeleteParams) middleware.Responder
	// OrderGet is For valid response try integer IDs with value >= 1 and <= 10. Other values will generated exceptions
	OrderGet(ctx context.Context, params store.OrderGetParams) middleware.Responder
}

// Config is configuration for Handler
type Config struct {
	PetAPI
	StoreAPI
	Logger func(string, ...interface{})
	// InnerMiddleware is for the handler executors. These do not apply to the swagger.json document.
	// The middleware executes after routing but before authentication, binding and validation
	InnerMiddleware func(http.Handler) http.Handler
	Auth            Auth
}

// Auth functions
type Auth interface {
	APIKey(token string) (interface{}, error)
	Basic(user, password string) (interface{}, error)
	OAuth2(token string, scopes []string) (interface{}, error)
	// AuthStore is a function that stores authentication in the context object
	Store(context.Context, interface{}) context.Context
}

// Handler returns an http.Handler given the handler configuration
// It mounts all the business logic implementers in the right routing.
func Handler(c Config) (http.Handler, error) {
	spec, err := loads.Analyzed(swaggerCopy(SwaggerJSON), "")
	if err != nil {
		return nil, fmt.Errorf("analyze swagger: %v", err)
	}
	api := operations.NewSwaggerPetstoreAPI(spec)
	api.ServeError = errors.ServeError
	api.Logger = c.Logger

	api.JSONConsumer = runtime.JSONConsumer()
	api.JSONProducer = runtime.JSONProducer()
	// Applies when the "Cookie" header is set
	if c.Auth == nil || c.Auth.APIKey == nil {
		return nil, fmt.Errorf("APIKey Authenticator was not defined")
	}
	if c.Auth == nil || c.Auth.Store == nil {
		return nil, fmt.Errorf("Auth store function was not defined")
	}
	api.KeyAuth = func(token string) (interface{}, error) {
		return c.Auth.APIKey(token)
	}

	// Set your custom authorizer if needed. Default one is security.Authorized()
	// Expected interface runtime.Authorizer
	//
	// Example:
	// api.APIAuthorizer = security.Authorized()
	api.StoreInventoryGetHandler = store.InventoryGetHandlerFunc(func(params store.InventoryGetParams, principal interface{}) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		ctx = c.Auth.Store(ctx, principal)
		return c.StoreAPI.InventoryGet(ctx, params)
	})
	api.StoreOrderCreateHandler = store.OrderCreateHandlerFunc(func(params store.OrderCreateParams, principal interface{}) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		ctx = c.Auth.Store(ctx, principal)
		return c.StoreAPI.OrderCreate(ctx, params)
	})
	api.StoreOrderDeleteHandler = store.OrderDeleteHandlerFunc(func(params store.OrderDeleteParams, principal interface{}) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		ctx = c.Auth.Store(ctx, principal)
		return c.StoreAPI.OrderDelete(ctx, params)
	})
	api.StoreOrderGetHandler = store.OrderGetHandlerFunc(func(params store.OrderGetParams, principal interface{}) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		ctx = c.Auth.Store(ctx, principal)
		return c.StoreAPI.OrderGet(ctx, params)
	})
	api.PetPetCreateHandler = pet.PetCreateHandlerFunc(func(params pet.PetCreateParams, principal interface{}) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		ctx = c.Auth.Store(ctx, principal)
		return c.PetAPI.PetCreate(ctx, params)
	})
	api.PetPetDeleteHandler = pet.PetDeleteHandlerFunc(func(params pet.PetDeleteParams, principal interface{}) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		ctx = c.Auth.Store(ctx, principal)
		return c.PetAPI.PetDelete(ctx, params)
	})
	api.PetPetGetHandler = pet.PetGetHandlerFunc(func(params pet.PetGetParams, principal interface{}) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		ctx = c.Auth.Store(ctx, principal)
		return c.PetAPI.PetGet(ctx, params)
	})
	api.PetPetListHandler = pet.PetListHandlerFunc(func(params pet.PetListParams, principal interface{}) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		ctx = c.Auth.Store(ctx, principal)
		return c.PetAPI.PetList(ctx, params)
	})
	api.PetPetUpdateHandler = pet.PetUpdateHandlerFunc(func(params pet.PetUpdateParams, principal interface{}) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		ctx = c.Auth.Store(ctx, principal)
		return c.PetAPI.PetUpdate(ctx, params)
	})
	api.ServerShutdown = func() {}
	return api.Serve(c.InnerMiddleware), nil
}

// Query parse functions for all the models
// Those can be used to extract database query from the http path's query string
var (
	OrderQueryParse    = query.MustNewBuilder(&query.Config{Model: models.Order{}}).ParseRequest
	PetQueryParse      = query.MustNewBuilder(&query.Config{Model: models.Pet{}}).ParseRequest
	CategoryQueryParse = query.MustNewBuilder(&query.Config{Model: models.Category{}}).ParseRequest
	TagQueryParse      = query.MustNewBuilder(&query.Config{Model: models.Tag{}}).ParseRequest
)

// swaggerCopy copies the swagger json to prevent data races in runtime
func swaggerCopy(orig json.RawMessage) json.RawMessage {
	c := make(json.RawMessage, len(orig))
	copy(c, orig)
	return c
}
